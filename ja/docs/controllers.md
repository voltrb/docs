# コントローラー

Volt では、コントローラーがどのクラスであっても構いませんが、通常は ModelController を継承したクラスとします。そのモデルコントローラーを使うことで、コントローラーによって利用されるモデルが明確になります。これは Volt で一般的に使われるパターンです。コントローラーが利用するモデルを設定するには以下のいずれかの方法を使います。

1. コレクションモデルの名前を示すシンボル:

```ruby
    class TodosController < Volt::ModelController
      model :page

      # ...
    end
```

2. メソッド内での `self.model=` の呼び出し:

```ruby
    class TodosController < Volt::ModelController
      def initialize
        self.model = :page
      end
    end
```

モデルが設定されると、存在しないメソッドの呼び出しはすべてそのモデルに対してプロキシされます。これによって、ビューの中でバインディングを行う際に、毎回モデルのオブジェクトを指定しなくても済むようになっています。また、現在設定されているモデルから変更したときにビューが自動的に更新されるのも、この仕組みがあるためです。

メソッド内で `#model` を実行したときの戻り値は現在設定されているモデルとなります。

[提供するコレクション](#提供するコレクション) の節に、利用可能なコレクションモデルのリストが記載されています。

また、自分で作成したオブジェクトをモデルとして提供することも可能です。

上記した例において、TodosController に定義されていないメソッドは、設定されているモデルにそのまま送られます。views/{コントローラー名} のすべてのビューにおいて、そのバインディングの中にある Ruby コードを実行する対象はこのコントローラーとなります。このことは、self に対する呼び出しは (それが暗黙であっても、self をつけて明示したものであっても)、(コントローラーを経由して) モデルを対象とすることを意味しています。このことによって、モデルの扱いに関するメソッドをコントローラーに追加したり、ビューに対して追加のメソッドを提供することが可能になっています。

Volt は MVC アーキテクチャよりも MVVM アーキテクチャに近いものです。そこでのコントローラーとは、ビューへのデータの受け渡しを行うものではなく、ビューのコンテキストを表すものだと言えます。Volt::ModelController を使うと、コントローラーは自分の扱うことのできないメソッドを自動的にモデルに引き継ぎます。このことは利便性を高めてくれます。なぜなら、コントローラーにモデルをセットし、バインディングのメソッドから直接そのプロパティにアクセスすることが可能であるからです。例えば、```{{ @model._name }}``` と書くのではなく、```{{ _name }}``` とすることができます。

app/home コンポーネントに配置されたコントローラーに対しては名前空間を指定する必要がありませんが、それ以外のコンポーネントでは、以下のようにコントローラーに名前空間を設定する必要があります:

```ruby
    module Auth
      class LoginController < Volt::ModelController
        # ...
      end
    end
```

この例では、「auth」がコンポーネント名となります。
